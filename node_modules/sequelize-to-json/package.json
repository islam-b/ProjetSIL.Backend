{
  "_from": "sequelize-to-json",
  "_id": "sequelize-to-json@0.10.3",
  "_inBundle": false,
  "_integrity": "sha1-F7keEslwWjQB16kiMqG2ZSUepC4=",
  "_location": "/sequelize-to-json",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "sequelize-to-json",
    "fetchSpec": "latest",
    "name": "sequelize-to-json",
    "raw": "sequelize-to-json",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/sequelize-to-json/-/sequelize-to-json-0.10.3.tgz",
  "_shasum": "17b91e12c9705a3401d7a92232a1b665251ea42e",
  "_spec": "sequelize-to-json",
  "_where": "C:\\Users\\islam\\WebstormProjects\\ProjetSIL",
  "author": {
    "name": "abstractpseudocitizen@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/hauru/sequelize-to-json/issues"
  },
  "bundleDependencies": false,
  "dependencies": {},
  "deprecated": false,
  "description": "Serialization of Sequelize models to JSON-compatible objects",
  "devDependencies": {},
  "homepage": "https://github.com/hauru/sequelize-to-json",
  "keywords": [
    "json",
    "model",
    "sequelize",
    "serialization"
  ],
  "license": "ISC",
  "main": "index.js",
  "name": "sequelize-to-json",
  "optionalDependencies": {},
  "readme": "# sequelize-to-json\n\nA fast, simple JSON serializer for your [Sequelize](https://github.com/sequelize/sequelize) models. Turns model instances into plain JSON-friendly objects that can be safely embedded in API responses. Suitable for serializing large numbers of instances at once.\n\nSerialization can be performed according to named _schemes_, of which any number can be defined for a model. A scheme specifies the properties to be be included or excluded in the result, and can also provide schemes to use for associated models.\n\n_Should_ work with both Sequelize 3.x and 4.x. Examples provided in this document are based on Sequelize 3. See [here](http://docs.sequelizejs.com/manual/tutorial/upgrade-to-v4.html) for the list of changes introduced in the new major release of Sequelize.\n\nProper test suite is the next thing on the roadmap. Until it comes into existence the package shoud not be considered stable.\n\n`sequelize-to-json` requires Node 4.4.x or later.\n\n## Installation\n\nInstall it within your project's tree using NPM: \n\n`npm install --save sequelize-to-json`\n\nThe module doesn't install any dependiences. It just ships with a custom minimized `lodash` build (to be removed in future releases).\n\n## Usage\n\nA nice walkthrough has yet to be written. For now, just a crude example.\n\nAssuming we already have a working Sequelize instance providing us with `User` and `BlogPost` models and at least the `author` relation:\n\n```js\nconst \n  Serializer = require('sequelize-to-json'),\n  db = require('./db'), // our Sequelize instance, with models and relations already defined\n  BlogPost = db.model('BlogPost'),\n  User = db.model('User');\n\n// our serialization scheme for the `BlogPost` model with the associated `User` (stored in the `author` field)\nconst scheme = {\n  // include all own properties and the associated `User` instance\n  include: ['@all', 'author'],\n  // let's exclude from the above the primary key and all foreign keys\n  exclude: ['@pk', '@fk'],\n  assoc: {\n    // scheme to be used for the associated `User` instance\n    author: {\n      // include just a selection of fields (URLs are method calls but they could be implemented as VIRTUAL attributes as well)\n      include: ['fullName', 'aboutMe', 'getProfileUrl', 'getAvatarUrl'],\n      // let's assign better names to properties obtained via instance methods\n      as: { getProfileUrl: 'profileUrl', getAvatarUrl: 'avatarUrl' }\n    }\n  }\n};\n  \n// now fetch some posts, with authors, and serialize them\nBlogPost.findAll({\n  include: { model: User, as: 'author' },\n  // ...\n}).then(function(posts) {\n  // serialize all the items efficiently\n  let postsAsJSON = Serializer.serializeMany(posts, BlogPost, schema);\n  \n  // serialize just the first item\n  let serializer = new Serializer(BlogPost, schema);\n  let postAsJSON = serializer.serialize(posts[0]);\n  // ...\n});\n```\n\nResulting JSONified post objects would look like this (assuming `BlogPost` contains the `title` and `content` fields):\n\n```js\n{\n  \"title\": ...,\n  \"content\": ...,\n  ...,\n  \"author\": {\n    \"fullName\": ...,\n    \"aboutMe\": ...,\n    \"profileUrl\": ...,\n    \"avatarUrl\": ...\n  }\n}\n```\n\nSee the [Reference](#reference) below for the complete description of `sequelize-to-json` features.\n\n## Reference\n\n### The `Serializer` class\n\nRepresents a serializer. \n\nSerializer objects can process any number of instances of a given model using the specified scheme. Both the model class and the scheme are tied to a serializer object; you'll need to instantiate a new serializer for each model / scheme pair. \n\nThis class is the only thing exported by the module. It can be accessed directly by requiring `sequelize-to-json`. \n\n(The class doesn't actually have a name of it's own; i'm using here the name `Serializer` just for clarity. You can import it under any name you wish.)\n\n<a id=\"serializer-serializer\"></a>\n#### `Serializer(model, [scheme, [options]])`\n\n\nCreates a new serializer.\n\nArguments are:\n\n* **`model`** - Sequelize model class whose instances are to be serialized\n* **`scheme`** - scheme to be used for serialization. Can be an object, a string or anything falsy.\n* **`options`** - object containing additional options (see [Options](#options))\n\nIf `scheme` is a string, the scheme definition will be searched for in `model.serializer.schemes`. If `scheme` is falsy, following steps will be performed to identify the serialization scheme:\n\n1. If `model.serializer.defaultScheme` is set, it will be interpreted as the name of scheme to use (from `model.serializer.schemes`).\n2. If there's no `model.serializer.defaultScheme`, the scheme is checked for in `model.serializer.schemes.default`.\n3. If there's no scheme named `default` in `model.serializer.schemes`, the global default scheme is used (see below).\n\nFor info on defining schemes, see the [schemes section](#defining-schemes).\n\n<a id=\"serializer-serialize\"></a>\n#### `#serialize(instance, [cacheObj])`\n\nSerializes a single model instance into a JSON-friendly object, according to the scheme provided in constructor.\n\n**`instance`** must be an instance of the proper model class, otherwise the method will throw an error.\n\n**`cacheObj`** should only be used if the `serialize` method is to be called repeatedly, eg. when processing a collection of model instances. In such cases, the `cacheObj` argument should be a reference to an existing plain object, which will serve as a cache for storing `Serializer` instances created recursively to process associated model instances.\n\nFor example:\n\n```js\nlet serializer = new Serializer(SomeModel, someScheme);\nlet cache = {}, json = [];\n\nfor(let item of items) {\n  json.push(serializer.serialize(item, cache));\n}\n```\n\nWithout passing `cache` in the `.serialize` call (or with `cache` being set inline to `{}`!) the performance will drop significantly since `Serializer` objects will have to be re-created for each item.\n\n<a id=\"serializer-serialize-many\"></a>\n#### `.serializeMany(instances, model, [scheme, [options]])`\n\nConvenience static method for serializing collections of model instances. It uses the `Serializer` object cache internally so that serializers are not re-created for associated model instances. See [`#serialize()`](#serializer-serialize) for details.\n\nThe `model`, `scheme` and `options` parameters are passed to the `Serializer` constructor.\n\n<a id=\"serializer-encode-to-json\"></a>\n#### `.encodeToJSON(obj, [options])`\n\nConverts regular Javascript objects into JSON-friendly format. This function is used by default for the conversion of values returned by Sequelize.\n\n**`obj`** is the object (value) to be encoded. **`options`** can be used to fine-tune the encoder.\n\nCurrently supported options:\n\n* **`bufferEncoding`** - how to encode binary `Buffer` contents into a string. The value gets passed to Node's `Buffer#toString()`. Default: `base64`\n\nNotes on how values are converted:\n\n* Strings, booleans, numbers and nulls are copied as is\n* Arrays and objects are processed recursively\n* Dates are stringified using `#toString()`\n* Buffers are stringified using `#toString()` with encoding specified in options\n\n<a id=\"serializer-default-options\"></a>\n#### `.defaultOptions`\n\nObject holding the global defaults for serialization [options](#options).\n\n<a id=\"schemes\"></a>\n### Defining schemes\n\n#### Scheme object\n\nScheme are defined as plain objects. They can contain following fields:\n\n* **`include`** - a list of attributes to be included in resulting objects. Defaults to all attributes (`['@all']`). See [Attribute lists](#attribute-lists) for details.\n* **`exclude`** - a list of attributes to be excluded from the result. Filtering is applied to the attribute list defined by `include`. Defaults to an empty list. See [Attribute lists](#attribute-lists) for details.\n* **`assoc`** - an object containing schemes for associated model instances. Object's keys should correspond to names of attributes holding related instances (Sequelize's `as`). Values can be either scheme names or scheme objects. They will be passed to the `Serializer` constructor when creating serializers for associated instances.\n* **`as`** - can be used to rename attributes in output. Should be an object mapping model attribute names to names we would like to have in JSON. Useful for naming properties obtained from method calls (eg. to have `postExcerpt` instead of `getPostExcerpt`).\n* **`options`** - serializer [options](#options). They will override options passed to the `Serializer` constructor.\n* **`postSerialize`** - the hook function to be called after the instance has been converted into object. It receives the output object as the first argument and the original instance as the second one. Must return the (modified) output object. Gets called *after* the [model-wide `postSerialize` hook](#schemes-inside-models).\n\n#### Attribute lists\n\nBoth the `include` and the `exclude` fields of a scheme definition should contain a list of model's attributes. But, these lists can be a little more than just plain arrays of attribute names. They can also contain:\n\n* method names (to be called with no arguments),\n* regular instance properties,\n* `@`-prefixed selectors that expand to subsets of model attributes sharing certain features.\n\nAttributes can be prefixed with a dot to mark them expicitely as regular attributes of the model instance object.\n\n`sequelize-to-json` provides support for following attribute selectors:\n\n* **`@all`** - all attributes defined for the model\n* **`@assoc`** - all associations in the model\n* **`@pk`** - the primary key (if present)\n* **`@fk`** - all foreign keys\n* **`@doc`** - all document-type fields: `JSON`, `JSONB`, `HSTORE`\n* **`@blob`** - all `BLOB`s\n* **`@virtual`** - all `VIRTUAL` attributes\n* **`@auto`** - all attributes auto-generated by Sequelize (eg. `created_at`, `updated_at`...)\n\nNote: model attribute values are obtained by calling `.get()` on the model instance. This means custom getters get executed.\n\n<a id=\"schemes-inside-models\"></a>\n#### Schemes inside models\n\nIn order to keep things clean, serialization schemes can be kept inside models. This is done by adding a static `serializer` property to the model class. You can either set this property directly or just put it in `classMethods` when defining the model.\n\nSupported `serializer` fields are:\n\n* **`schemes`** - an object containing available serialization schemes (keys are names and values are scheme objects)\n* **`defaultScheme`** - name of the default scheme for this model. The name should exist as a proper key in `schemes`.\n* **`options`** - model-wide defaults for [serialization options](#options)\n* **`postSerialize`** - the model-wide hook function to be called after the instance has been converted into object. It gets called with the serialization scheme as `this` and receives 3 arguments: the output object, the original model instance and the name of the serialization scheme. Must return the (modified) output object. Gets called *before* the scheme-specific `postSerialize` hook.\n\n### Options\n\nFollowing options can be used to tune the serialization output:\n\n* **`encoder`** - a function used to convert JS types to JSON-friendly format. It should accept an object to be encoded and can be also passed options. Default: [`Serializer.encodeToJSON()`](#serializer-encode-to-json)\n* **`undefinedPolicy`** - what to do with attributes that are `undefined` for the instance. Allowed policies are `Serializer.SKIP` (exclude from output), `Serializer.SET_NULL` (set their values to `null`) and `Serializer.FAIL` (throw an error). Default: `Serializer.SKIP`\n* **`copyJSONFields`** - whether values stored as JSON (`JSON`, `JSONB` etc.) should be copied directly without passing them through `encoder`. Having it on will improve performance a bit. Default: `true`\n* **`simpleDates`** - whether `DATEONLY` fields should be encoded in `YYYY-MM-DD` format with the timezone offset applied. If set to `false`, they will be stringified as full date-times. Default: `true`. Note: In Sequelize 4 `DATEONLY` fields are implemented as strings model-side so this option will have no effect.\n* **`encoderOptions`** - options to be passed to `encoder` (as the second argument)\n* **`attrFilter`** - function to filter model attributes before serialization. Can be useful in certain cases, eg. when one wants to get rid of duplicates of auto-generated attributes (such as `some_id` showing up together with `someId`). The function gets passed 2 arguments: the attribute object and the model object. It should return `false` for the attribute to be excluded from serialization.\n\nAbove options can be customized in four different places altogether (with precedence from the top to the bottom):\n\n* in [constructor](#serializer-serializer) (passed as the last argument);\n* inside a [scheme object](#schemes);\n* [inside a model](#schemes-inside-models);\n* globally, by modifying `Serializer.defaultOptions`.\n\n## Tips\n\n### Adding serialization methods to models\n\nTo save yourself some typing and `require`ing across the application code, you can add serialization methods globally to all your models. Just use `define.classMethods` and `define.instanceMethods` options during Sequelize instantiation:\n\n```js\nconst db = new Sequelize(..., {\n  //...\n  define: {\n    classMethods: {\n      serializeMany: function(data, scheme, options) {\n        return Serializer.serializeMany(data, this, scheme, options);\n      },\n      //...\n    },\n    instanceMethods: {\n      serialize: function(scheme, options) {\n        return (new Serializer(this.Model, scheme, options)).serialize(this);\n      },\n      //...\n    }\n  },\n  //...\n});\n\n```\n\nNow you can use these methods like so:\n\n```js\n// for single object\nlet json = myModelInstance.serialize('someScheme');\n// for many objects\nlet json = MyModel.serializeMany(instances, 'someScheme');\n```\n\nOf course you can provide the scheme as an object and pass serializer options as the last argument for both methods.\n\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/hauru/sequelize-to-json.git"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "version": "0.10.3"
}
